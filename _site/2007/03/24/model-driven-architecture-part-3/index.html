<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Model Driven Architecture [part 3] | Your awesome title</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Model Driven Architecture [part 3]" />
<meta name="author" content="Ben" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This will be a short post, but I thought it would be interesting to look at one specific offering of an MDA product to see what they can do.  OptimalJ is made by Compuware and provides MDA programming for those of use that live in a J2EE world. To start things off, this PDF file is one of their marketing releases, but as we look through it, we can see the foundations of what makes an MDA product. OptimalJ consists of three basic components.  (1) Metamodels create separation between application design, infrastructure, and code.  (2) Technology patterns make model-to-model transformation possible. (3) Finally, implementation patterns allow for the model-to-code transformation. Metamodels: At the high level, you need to separate the different aspects of your applications so that you can address the concerns of each individual piece before you bring it all together to work out those issues.  Since we’ve started breaking things down into threes (3 MDA posts and 3 OptimalJ components) we’ll do one final three-part breakdown.  There are three kinds of metamodels.  The domain model, the application model, and the code model. Proper usage of these metamodels formally defines the kinds of data needed by the application,  what technology the application will be using, and specific code pieces that will be used in certain situations.  This last part is a bit confusing, but the OptimalJ product allows for editing of templates (of a sort) that will later be used during the translation of model-to-code. Technology Patterns: above we mentioned that this provides model-to-model transformation.  Specifically, this provides for the transformation of the domain model into the application model.  So starting from the kind of data that we want, we now translate that into the architecture of our application.  What kind of application is this?  Web-based, client-server, etc. Implementation Patterns:   this transforms the application model into the code model.  This is where actual code is produced. OptimalJ provides graphical editors for all these different pieces, but breaking it down this way, we can begin to see what OptimalJ can do.  We start up front with the need for an application.  After defining what data we need in the data model, we can generate an application model that provides an overview of the application itself.  Further transformation into the code model gives an application that can be compiled and run. If we change the way the data should be stored, we can regenerate the application model and the code model and cut out all the in-betweens of recoding to match our new data structure.  All this auto-generation even includes SQL scripts for datbase creation if you’re willing to spring for the higher-end versions.  Eclipse support and Netbeans support virtually guarantees that you’ll be in a familiar environment.  Is there anyone in the world that still writes Java outside of those IDEs?" />
<meta property="og:description" content="This will be a short post, but I thought it would be interesting to look at one specific offering of an MDA product to see what they can do.  OptimalJ is made by Compuware and provides MDA programming for those of use that live in a J2EE world. To start things off, this PDF file is one of their marketing releases, but as we look through it, we can see the foundations of what makes an MDA product. OptimalJ consists of three basic components.  (1) Metamodels create separation between application design, infrastructure, and code.  (2) Technology patterns make model-to-model transformation possible. (3) Finally, implementation patterns allow for the model-to-code transformation. Metamodels: At the high level, you need to separate the different aspects of your applications so that you can address the concerns of each individual piece before you bring it all together to work out those issues.  Since we’ve started breaking things down into threes (3 MDA posts and 3 OptimalJ components) we’ll do one final three-part breakdown.  There are three kinds of metamodels.  The domain model, the application model, and the code model. Proper usage of these metamodels formally defines the kinds of data needed by the application,  what technology the application will be using, and specific code pieces that will be used in certain situations.  This last part is a bit confusing, but the OptimalJ product allows for editing of templates (of a sort) that will later be used during the translation of model-to-code. Technology Patterns: above we mentioned that this provides model-to-model transformation.  Specifically, this provides for the transformation of the domain model into the application model.  So starting from the kind of data that we want, we now translate that into the architecture of our application.  What kind of application is this?  Web-based, client-server, etc. Implementation Patterns:   this transforms the application model into the code model.  This is where actual code is produced. OptimalJ provides graphical editors for all these different pieces, but breaking it down this way, we can begin to see what OptimalJ can do.  We start up front with the need for an application.  After defining what data we need in the data model, we can generate an application model that provides an overview of the application itself.  Further transformation into the code model gives an application that can be compiled and run. If we change the way the data should be stored, we can regenerate the application model and the code model and cut out all the in-betweens of recoding to match our new data structure.  All this auto-generation even includes SQL scripts for datbase creation if you’re willing to spring for the higher-end versions.  Eclipse support and Netbeans support virtually guarantees that you’ll be in a familiar environment.  Is there anyone in the world that still writes Java outside of those IDEs?" />
<link rel="canonical" href="http://localhost:4000/2007/03/24/model-driven-architecture-part-3/" />
<meta property="og:url" content="http://localhost:4000/2007/03/24/model-driven-architecture-part-3/" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2007-03-24T23:19:08-06:00" />
<script type="application/ld+json">
{"headline":"Model Driven Architecture [part 3]","dateModified":"2007-03-24T23:19:08-06:00","datePublished":"2007-03-24T23:19:08-06:00","url":"http://localhost:4000/2007/03/24/model-driven-architecture-part-3/","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2007/03/24/model-driven-architecture-part-3/"},"author":{"@type":"Person","name":"Ben"},"description":"This will be a short post, but I thought it would be interesting to look at one specific offering of an MDA product to see what they can do.  OptimalJ is made by Compuware and provides MDA programming for those of use that live in a J2EE world. To start things off, this PDF file is one of their marketing releases, but as we look through it, we can see the foundations of what makes an MDA product. OptimalJ consists of three basic components.  (1) Metamodels create separation between application design, infrastructure, and code.  (2) Technology patterns make model-to-model transformation possible. (3) Finally, implementation patterns allow for the model-to-code transformation. Metamodels: At the high level, you need to separate the different aspects of your applications so that you can address the concerns of each individual piece before you bring it all together to work out those issues.  Since we’ve started breaking things down into threes (3 MDA posts and 3 OptimalJ components) we’ll do one final three-part breakdown.  There are three kinds of metamodels.  The domain model, the application model, and the code model. Proper usage of these metamodels formally defines the kinds of data needed by the application,  what technology the application will be using, and specific code pieces that will be used in certain situations.  This last part is a bit confusing, but the OptimalJ product allows for editing of templates (of a sort) that will later be used during the translation of model-to-code. Technology Patterns: above we mentioned that this provides model-to-model transformation.  Specifically, this provides for the transformation of the domain model into the application model.  So starting from the kind of data that we want, we now translate that into the architecture of our application.  What kind of application is this?  Web-based, client-server, etc. Implementation Patterns:   this transforms the application model into the code model.  This is where actual code is produced. OptimalJ provides graphical editors for all these different pieces, but breaking it down this way, we can begin to see what OptimalJ can do.  We start up front with the need for an application.  After defining what data we need in the data model, we can generate an application model that provides an overview of the application itself.  Further transformation into the code model gives an application that can be compiled and run. If we change the way the data should be stored, we can regenerate the application model and the code model and cut out all the in-betweens of recoding to match our new data structure.  All this auto-generation even includes SQL scripts for datbase creation if you’re willing to spring for the higher-end versions.  Eclipse support and Netbeans support virtually guarantees that you’ll be in a familiar environment.  Is there anyone in the world that still writes Java outside of those IDEs?","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about-me.html">About Me</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Model Driven Architecture [part 3]</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2007-03-24T23:19:08-06:00" itemprop="datePublished">Mar 24, 2007
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Ben</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This will be a short post, but I thought it would be interesting to look at one specific offering of an MDA product to see what they can do.  OptimalJ is made by Compuware and provides MDA programming for those of use that live in a J2EE world.</p>

<p>To start things off, <a href="http://www.compuware.com/products/optimalj/resources/4639_ENG_HTML.asp" title="OptimalJ Fact Sheet (this is a pdf file)">this PDF</a> file is one of their marketing releases, but as we look through it, we can see the foundations of what makes an MDA product.</p>

<p>OptimalJ consists of three basic components.  (1) Metamodels create separation between application design, infrastructure, and code.  (2) Technology patterns make model-to-model transformation possible. (3) Finally, implementation patterns allow for the model-to-code transformation.</p>

<p>Metamodels: At the high level, you need to separate the different aspects of your applications so that you can address the concerns of each individual piece before you bring it all together to work out those issues.  Since we’ve started breaking things down into threes (3 MDA posts and 3 OptimalJ components) we’ll do one final three-part breakdown.  There are three kinds of metamodels.  The domain model, the application model, and the code model.</p>

<p>Proper usage of these metamodels formally defines the kinds of data needed by the application,  what technology the application will be using, and specific code pieces that will be used in certain situations.  This last part is a bit confusing, but the OptimalJ product allows for editing of templates (of a sort) that will later be used during the translation of model-to-code.</p>

<p>Technology Patterns: above we mentioned that this provides model-to-model transformation.  Specifically, this provides for the transformation of the domain model into the application model.  So starting from the kind of data that we want, we now translate that into the architecture of our application.  What kind of application is this?  Web-based, client-server, etc.</p>

<p>Implementation Patterns:   this transforms the application model into the code model.  This is where actual code is produced.</p>

<p>OptimalJ provides graphical editors for all these different pieces, but breaking it down this way, we can begin to see what OptimalJ can do.  We start up front with the need for an application.  After defining what data we need in the data model, we can generate an application model that provides an overview of the application itself.  Further transformation into the code model gives an application that can be compiled and run.</p>

<p>If we change the way the data should be stored, we can regenerate the application model and the code model and cut out all the in-betweens of recoding to match our new data structure.  All this auto-generation even includes SQL scripts for datbase creation if you’re willing to spring for the higher-end versions.  Eclipse support and Netbeans support virtually guarantees that you’ll be in a familiar environment.  Is there anyone in the world that still writes Java outside of those IDEs?</p>

  </div><a class="u-url" href="/2007/03/24/model-driven-architecture-part-3/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
